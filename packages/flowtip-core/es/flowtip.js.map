{"version":3,"sources":["../src/flowtip.js"],"names":["Rect","TOP","RIGHT","BOTTOM","LEFT","START","CENTER","END","getRect","config","region","target","content","align","offset","left","top","width","height","bottom","right","getOffsetBounds","bounds","edgeOffset","maxOffset","Math","max","constrainLeft","offsetBounds","rect","constrain","constrainTop","getRegionClip","getValidRegions","overlap","grow","topBottomValid","leftRightValid","topMargin","rightMargin","bottomMargin","leftMargin","topRegion","rightRegion","bottomRegion","leftRegion","topClips","rightClips","bottomClips","leftClips","getIdealRegion","valid","disabled","margin","undefined","getExternalRegion","atTop","atLeft","atBottom","atRight","topDist","rightDist","bottomDist","leftDist","upperTopLeft","lowerTopLeft","upperTopRight","lowerTopRight","lowerBottomRight","upperBottomRight","lowerBottomLeft","upperBottomLeft","invertRegion","getDefaultRegion","getInvertDefaultRegion","invertedDefault","getFallbackRegion","fallback","Object","keys","find","getRegion","ideal","defaultRegion","external","constrainRect","getOffset","getOverlap","intersect","getCenter","allRegions","noRegions","normalizeAlign","defaults","from","flowtip","finalConfig","reason","tempRect","overlapCenter"],"mappings":"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","sourcesContent":["// @flow\nimport Rect from './Rect';\nimport type {RectLike} from './Rect';\n\nexport type Region = 'top' | 'right' | 'bottom' | 'left';\nexport type Reason = 'default' | 'inverted' | 'ideal' | 'external' | 'fallback';\nexport type Dimensions = {width: number, height: number};\nexport type Align = 'start' | 'center' | 'end' | number;\ntype _Regions = {\n  top: boolean,\n  right: boolean,\n  bottom: boolean,\n  left: boolean,\n};\nexport type Regions = $Shape<_Regions>;\nexport type Result = {\n  bounds: Rect,\n  target: Rect,\n  region: Region,\n  reason: Reason,\n  rect: Rect,\n  valid: _Regions,\n  offset: number,\n  overlap: number,\n  overlapCenter: number,\n};\ntype _Config = {\n  offset: number,\n  overlap: number,\n  edgeOffset: number,\n  align: number,\n  region?: Region,\n  bounds: Rect,\n  target: Rect,\n  content: Dimensions,\n  disabled: _Regions,\n  constrain: _Regions,\n};\nexport type Config = {\n  offset?: number,\n  overlap?: number,\n  edgeOffset?: number,\n  align?: Align,\n  region?: Region,\n  bounds: RectLike | Rect,\n  target: RectLike | Rect,\n  content: Dimensions,\n  disabled?: Regions,\n  constrain?: Regions,\n};\n\nexport const TOP: Region = 'top';\nexport const RIGHT: Region = 'right';\nexport const BOTTOM: Region = 'bottom';\nexport const LEFT: Region = 'left';\n\nexport const START: Align = 'start';\nexport const CENTER: Align = 'center';\nexport const END: Align = 'end';\n\n/**\n * Get the position of the content rect when moved into the supplied region and\n * aligned with `config.align`. The returned rect represents the ideal content\n * position before any boundary constrains are applied.\n *\n * The `config.align` value determines how the content rect will be positioned\n * relative to the target rect. A `conifg.align` value of 0 will align it to the\n * start (left or top) of the target while a value of 1 will align the rect to\n * the end (right or bottom). A value of 0.5 will center align it in every\n * orientation.\n *\n * @param   {Object} config FlowTip layout config object.\n * @param   {string} region A region (`top`, `right`, `bottom`, or `left`).\n * @returns {Object} A rect object.\n */\nfunction getRect(config: _Config, region: Region): Rect {\n  const {target, content, align, offset} = config;\n\n  let left;\n  let top;\n\n  if (region === TOP || region === BOTTOM) {\n    left = target.left + (target.width - content.width) * align;\n\n    if (region === TOP) {\n      top = target.top - content.height - offset;\n    } else {\n      // Region is bottom.\n      top = target.bottom + offset;\n    }\n  } else {\n    // Region is left or right.\n    top = target.top + (target.height - content.height) * align;\n\n    if (region === LEFT) {\n      left = target.left - content.width - offset;\n    } else {\n      // Region is right.\n      left = target.right + offset;\n    }\n  }\n\n  return new Rect(left, top, content.width, content.height);\n}\n\n/**\n * Calculate the final effective bounds of the positioned content rect for a\n * given region.\n *\n * This calculation uses the maximum of the target offset and edge offset config\n * values as the offset along the edge of the content facing the target. This\n * prevents the content from being offset from the boundary edge by both offset\n * amounts (the target offset is used to provide space for an indicator triangle\n * and only applies in the direction facing the target).\n *\n * @param   {Object} config FlowTip layout config object.\n * @param   {string} region A region (`top`, `right`, `bottom`, or `left`).\n * @returns {Object} A rect object\n */\nfunction getOffsetBounds(config: _Config, region: Region): Rect {\n  const {bounds, edgeOffset, offset} = config;\n  const maxOffset = Math.max(offset, edgeOffset);\n\n  const left = bounds.left + (region === RIGHT ? maxOffset : edgeOffset);\n  const top = bounds.top + (region === BOTTOM ? maxOffset : edgeOffset);\n  const right = bounds.right - (region === LEFT ? maxOffset : edgeOffset);\n  const bottom = bounds.bottom - (region === TOP ? maxOffset : edgeOffset);\n\n  return new Rect(left, top, right - left, bottom - top);\n}\n\n/**\n * Get the updated left position of the content rect with boundary constraints\n * applied.\n *\n * @param   {Object} config FlowTip layout config object.\n * @param   {string} region A region (`top`, `right`, `bottom`, or `left`).\n * @param   {Object} offsetBounds A final bounds rect for the current region.\n * @param   {Object} rect A content rect object.\n * @returns {number} A new left position for the content rect.\n */\nfunction constrainLeft(\n  config: _Config,\n  region: Region,\n  offsetBounds: Rect,\n  rect: Rect,\n): number {\n  const {constrain, bounds} = config;\n\n  // Center align the content rect if is wider than the bounds rect.\n  if (constrain.left && constrain.right && rect.width > offsetBounds.width) {\n    return bounds.left + (bounds.width - rect.width) / 2;\n  }\n\n  // If either the left or right edge of the content rect is outside the bounds\n  // rect, position it on the edge. Only one of these cases can be true since\n  // the content is not wider than the bounds.\n  if (constrain.left && rect.left < offsetBounds.left) {\n    return offsetBounds.left;\n  }\n\n  if (constrain.right && rect.right > offsetBounds.left + offsetBounds.width) {\n    return offsetBounds.right - rect.width;\n  }\n\n  return rect.left;\n}\n\n/**\n * Get the updated top position of the content rect with boundary constraints\n * applied.\n *\n * @param   {Object} config FlowTip layout config object.\n * @param   {string} region A region (`top`, `right`, `bottom`, or `left`).\n * @param   {Object} offsetBounds A final bounds rect for the current region.\n * @param   {Object} rect A content rect object.\n * @returns {number} A new top position for the content rect.\n */\nfunction constrainTop(\n  config: _Config,\n  region: Region,\n  offsetBounds: Rect,\n  rect: Rect,\n): number {\n  const {constrain, bounds} = config;\n\n  // Center align the content rect if is taller than the bounds rect.\n  if (constrain.top && constrain.bottom && rect.height > offsetBounds.height) {\n    return bounds.top + (bounds.height - rect.height) / 2;\n  }\n\n  // If either the left or right edge of the content rect is outside the bounds\n  // rect, position it on the edge. Only one of these cases can be true since\n  // the content is not taller than the bounds.\n  if (constrain.top && rect.top < offsetBounds.top) {\n    return offsetBounds.top;\n  }\n\n  if (constrain.bottom && rect.bottom > offsetBounds.bottom) {\n    return offsetBounds.bottom - rect.height;\n  }\n\n  return rect.top;\n}\n\n/**\n * Check if the content will be clipped by the boundary edge if placed in a\n * region.\n *\n * @param   {Object} config FlowTip layout config object.\n * @param   {string} region A region (`top`, `right`, `bottom`, or `left`)\n * @returns {Object} Clipped regions (`{top, right, bottom, left}`).\n */\nfunction getRegionClip(config: _Config, region: Region): _Regions {\n  const rect = getRect(config, region);\n  const offsetBounds = getOffsetBounds(config, region);\n\n  return {\n    top: rect.top < offsetBounds.top,\n    right: offsetBounds.right < rect.right,\n    bottom: offsetBounds.bottom < rect.bottom,\n    left: rect.left < offsetBounds.left,\n  };\n}\n\n/**\n * Calculate which regions are valid for the content rect to occupy.\n * This function measures the available space around the target rect within the\n * container rect. Any region with sufficient space to display the content rect\n * without clipping is set to `true`.\n *\n * This function checks the margins between the target rect and the bounds rect\n * in every region when offset from the the target. If a margin is smaller than\n * the width or height of the height of the content rect, that region is not\n * valid.\n *\n *  _________________________________________________________________\n * |                   ^                                             |\n * |                   |                                             |\n * |                  top                                            |\n * |                 margin   |‾‾‾‾‾‾‾‾‾‾‾|                          |\n * |                   |      |  content  |                          |\n * |                  _V_ _ _ |___________|    |<----right-margin--->|\n * |                                |          |                     |\n * |         |‾‾‾‾‾‾‾‾‾‾‾|     _____|_____     |‾‾‾‾‾‾‾‾‾‾‾|         |\n * |         |  content  |----|  target   |----|  content  |         |\n * |         |___________|     ‾‾‾‾‾|‾‾‾‾‾     |___________|         |\n * |                     |          |                                |\n * |<----left-margin---->|    |‾‾‾‾‾‾‾‾‾‾‾| ‾ ‾<- bottom margin      |\n *  ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|  content  |‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n *                            |___________|\n * > bottom margin is smaller than the content height, this region is disabled\n *\n * In addition to checking the margins, this function also checks that enough\n * of the target rect intersects with the bounds rect in each direction to\n * accommodate the `overlap` value set in the config. This calculation allows\n * a region to be considered invalid if there is not enough room to render\n * a caret.\n *\n *               |                                                   |\n *               |<--L-->|------------min-overlap------------|<--R-->|\n *               |                                                   |\n *               |<-left-intersection->|                             |\n *               |                     |                             |\n *               |   __________________|                             |\n *               |  |      target      |                             |\n *               |  |‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾                              |\n *               |  |<--------------right-intersection-------------->|\n *               |           ^                                       |\n *               | |‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|                            |\n *               | |       content      |                            |\n *               | |____________________|                            |\n *               |                                                   |\n * > Sufficient intersection at the left and right, the top and bottom\n * > regions are considered valid.\n *\n *               |                                                   |\n *               |<--L-->|------------min-overlap------------|<--R-->|\n *               |                                                   |\n *               |<-->|--left-intersection                           |\n *               |    |                                              |\n *  _____________|____|      |‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|                  |\n * |      target      |    < |       content      |                  |\n * |‾‾‾‾‾‾‾‾‾‾‾‾‾|‾‾‾‾       |____________________|                  |\n * |             |                                                   |\n * |<------------+----------right-intersection---------------------->|\n *               |                                                   |\n * > Insufficient intersection at the left, the top and bottom regions are\n * > not considered valid. Only the right region is valid.\n *\n * @param   {Object} config FlowTip layout config object.\n * @returns {Object} Valid regions (`{top, right, bottom, left}`).\n */\nfunction getValidRegions(config: _Config): _Regions {\n  const {\n    target,\n    overlap,\n    offset,\n    edgeOffset,\n    bounds,\n    content,\n    constrain,\n  } = config;\n\n  const offsetBounds = Rect.grow(bounds, -edgeOffset);\n\n  // This value is true if `overlap` amount of the target rect intersects\n  // the bounds rect in the horizontal direction.\n  const topBottomValid =\n    offsetBounds.right - target.left >= overlap &&\n    target.right - offsetBounds.left >= overlap;\n\n  // This value is true if `overlap` amount of the target rect intersects\n  // the bounds rect in the vertical direction.\n  const leftRightValid =\n    offsetBounds.bottom - target.top >= overlap &&\n    target.bottom - offsetBounds.top >= overlap;\n\n  // Calculate the available space in each region.\n  const topMargin = target.top - offsetBounds.top - offset;\n  const rightMargin = offsetBounds.right - target.right - offset;\n  const bottomMargin = offsetBounds.bottom - target.bottom - offset;\n  const leftMargin = target.left - offsetBounds.left - offset;\n\n  const topRegion = getRegionClip(config, TOP);\n  const rightRegion = getRegionClip(config, RIGHT);\n  const bottomRegion = getRegionClip(config, BOTTOM);\n  const leftRegion = getRegionClip(config, LEFT);\n\n  const topClips =\n    (!constrain.left && topRegion.left) ||\n    (!constrain.right && topRegion.right);\n  const rightClips =\n    (!constrain.top && rightRegion.top) ||\n    (!constrain.bottom && rightRegion.bottom);\n  const bottomClips =\n    (!constrain.left && bottomRegion.left) ||\n    (!constrain.right && rightRegion.bottom);\n  const leftClips =\n    (!constrain.top && topRegion.top) ||\n    (!constrain.bottom && leftRegion.bottom);\n\n  // A region is considered valid if the margin is large enough to fit the\n  // side of the content rect and if there is enough linear overlap as defined\n  // in the config. The overlap check ensures that a region is valid only if\n  // there is room to render a caret.\n  return {\n    top: !topClips && topBottomValid && topMargin >= content.height,\n    right: !rightClips && leftRightValid && rightMargin >= content.width,\n    bottom: !bottomClips && topBottomValid && bottomMargin >= content.height,\n    left: !leftClips && leftRightValid && leftMargin >= content.width,\n  };\n}\n\n/**\n * Get the ideal region to position the content rect. This function returns the\n * region adjacent to the target that has the largest available space.\n *\n * If there are no regions that are large enough to fit the content rect\n * `undefined` is returned.\n *\n *     ___________________________________________________________________\n *    |                      ^                                            |\n *    |                      |                                            |\n *    |                      V                                            |\n *    |                 |‾‾‾‾‾‾‾‾‾‾|                                      |\n *    |                 | content  |                                      |\n *    |                 |__________|                                      |\n *    |   |‾‾‾‾‾‾‾‾‾‾|   ____|_____   |‾‾‾‾‾‾‾‾‾‾|                        |\n *    |<->| content  |--|  target  |--| content  |<---------------------->|\n *    |   |__________|   ‾‾‾‾|‾‾‾‾‾   |__________|                        |\n *    |                 |‾‾‾‾‾‾‾‾‾‾|                                      |\n *    |                 | content  |                                      |\n *    |                 |__________|                                      |\n *    |                      ^                                            |\n *    |                      |                                            |\n *    |                      V                                            |\n *     ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n * > Although all regions are valid, the region with largest available space\n * > (right) returned as the ideal region.\n *\n * @param   {Object} config FlowTip layout config object.\n * @param   {Object} valid Valid regions (`{top, right, bottom, left}`).\n * @returns {string|undefined} A region (`top`, `right`, `bottom`, or `left`).\n */\nfunction getIdealRegion(config: _Config, valid: _Regions): ?Region {\n  const {target, content, disabled, bounds} = config;\n\n  let margin = 0;\n  let region = undefined;\n\n  // Calculate the amount of remaining free space in each region when occupied\n  // by the content rect. It is not necessary to factor `offset` into this\n  // calculation since it is constant for all regions.\n  const topMargin = target.top - bounds.top - content.height;\n  const rightMargin = bounds.right - target.right - content.width;\n  const bottomMargin = bounds.bottom - target.bottom - content.height;\n  const leftMargin = target.left - bounds.left - content.width;\n\n  if (valid.top && !disabled.top && topMargin > margin) {\n    margin = topMargin;\n    region = TOP;\n  }\n\n  if (valid.right && !disabled.right && rightMargin > margin) {\n    margin = rightMargin;\n    region = RIGHT;\n  }\n\n  if (valid.bottom && !disabled.bottom && bottomMargin > margin) {\n    margin = bottomMargin;\n    region = BOTTOM;\n  }\n\n  if (valid.left && !disabled.left && leftMargin > margin) {\n    margin = leftMargin;\n    region = LEFT;\n  }\n\n  return region;\n}\n\n/**\n * Resolve a region when the target rect is positioned outside of the bounds\n * rect.\n *\n * This algorithm checks which triangular segment around the bounds rect is\n * occupied and returned the associated region.\n *\n *           \\                   top quadrant                  /\n *             \\            returns bottom region            /\n *               \\                                         /\n *                 \\      top-left    |    top-right     /\n *                   \\    upper half  |    upper half  /\n *                     \\              |              /\n *                       \\            |            /\n *                         \\__________|__________/\n *               top-left  | \\        |        / | top-right\n *  left       lower half  |   \\      |      /   | lower half         right\n *  quadrant               |     \\    |    /     |                 quadrant\n *  returns   -------------|------+---+---+------|--------------    returns\n *  right                  |     /    |    \\     |                     left\n *  region    bottom-left  |   /      |      \\   |  bottom-right     region\n *              upper half | /        |        \\ |  upper half\n *                         /‾‾‾‾‾‾‾‾‾‾|‾‾‾‾‾‾‾‾‾‾\\\n *                       /            |            \\\n *                     /              |              \\\n *                   /   bottom-left  |  bottom-right  \\\n *                 /      lower half  |  lower half      \\\n *               /                                         \\\n *             /               bottom quadrant               \\\n *           /               returns top region                \\\n *\n * > The quadrants are divided at 45 degree angles and extend outward and inward\n * > from each edge.\n *\n * When an edge constraint is disabled, the logic for that quadrant is skipped.\n * The halves of the adjacent quadrants are also skipped.\n *\n * For example, if the bottom constraint is disabled, the bottom halves of the\n * left and right quadrants do not exist. The top halves extend indefinitely\n * downwards so that the top region is never returned when the target rect is\n * not directly below the bounds rect.\n *\n *                       \\            |            /\n *                         \\__________|__________/\n *               top-left  | \\        |        / | top-right\n *  left       lower half  |   \\      |      /   | lower half         right\n *  quadrant               |     \\    |    /     |                 quadrant\n *  returns   -------------|------+---+---+------|--------------    returns\n *  right                  |                     |                     left\n *  region    bottom-left  |      contrain       |  bottom-right     region\n *              upper half |      disabled       |  upper half\n *                         |‾ ‾ ‾ ‾ ‾ ‾ ‾ ‾ ‾ ‾ ‾|\n *               quadrant  |     handled by      |  quadrant\n *                extents  |   getIdealRegion    |  extends\n *            indefinitely |                     |  indefinitely\n *                         |                     |\n *\n * @param   {Object} config FlowTip layout config object.\n * @returns {string|undefined} A region (`top`, `right`, `bottom`, or `left`).\n */\nfunction getExternalRegion(config: _Config): ?Region {\n  const {target, constrain, bounds, edgeOffset, disabled} = config;\n\n  const offsetBounds = Rect.grow(bounds, -edgeOffset);\n\n  const atTop =\n    target.top + target.height / 2 < offsetBounds.top + offsetBounds.height / 2;\n\n  const atLeft =\n    target.left + target.width / 2 < offsetBounds.left + offsetBounds.width / 2;\n\n  const atBottom = !atTop;\n  const atRight = !atLeft;\n\n  const topDist = offsetBounds.top - target.bottom;\n  const rightDist = target.left - offsetBounds.right;\n  const bottomDist = target.top - offsetBounds.bottom;\n  const leftDist = offsetBounds.left - target.right;\n\n  const upperTopLeft = atTop && atLeft && topDist >= leftDist;\n  const lowerTopLeft = atTop && atLeft && topDist < leftDist;\n\n  const upperTopRight = atTop && atRight && topDist >= rightDist;\n  const lowerTopRight = atTop && atRight && topDist < rightDist;\n\n  const lowerBottomRight = atBottom && atRight && bottomDist >= rightDist;\n  const upperBottomRight = atBottom && atRight && bottomDist < rightDist;\n\n  const lowerBottomLeft = atBottom && atLeft && bottomDist >= leftDist;\n  const upperBottomLeft = atBottom && atLeft && bottomDist < leftDist;\n\n  if (!disabled.top) {\n    if (lowerBottomRight && constrain.bottom) return TOP;\n    if (lowerBottomRight && !constrain.right) return TOP;\n    if (lowerBottomLeft && constrain.bottom) return TOP;\n    if (lowerBottomLeft && !constrain.left) return TOP;\n    if (upperBottomRight && constrain.bottom && disabled.left) return TOP;\n    if (upperBottomLeft && constrain.bottom && disabled.right) return TOP;\n    if (upperBottomLeft && !constrain.left && constrain.bottom) return TOP;\n    if (upperBottomRight && !constrain.right && constrain.bottom) return TOP;\n  }\n\n  if (!disabled.right) {\n    if (upperBottomLeft && constrain.left) return RIGHT;\n    if (upperBottomLeft && !constrain.bottom) return RIGHT;\n    if (lowerTopLeft && constrain.left) return RIGHT;\n    if (lowerTopLeft && !constrain.top) return RIGHT;\n    if (lowerBottomLeft && constrain.left && disabled.top) return RIGHT;\n    if (upperTopLeft && constrain.left && disabled.bottom) return RIGHT;\n    if (upperTopLeft && !constrain.top && constrain.left) return RIGHT;\n    if (lowerBottomLeft && !constrain.bottom && constrain.left) return RIGHT;\n  }\n\n  if (!disabled.bottom) {\n    if (upperTopLeft && constrain.top) return BOTTOM;\n    if (upperTopLeft && !constrain.left) return BOTTOM;\n    if (upperTopRight && constrain.top) return BOTTOM;\n    if (upperTopRight && !constrain.right) return BOTTOM;\n    if (lowerTopLeft && constrain.top && disabled.right) return BOTTOM;\n    if (lowerTopRight && constrain.top && disabled.left) return BOTTOM;\n    if (lowerTopRight && !constrain.right && constrain.top) return BOTTOM;\n    if (lowerTopLeft && !constrain.left && constrain.top) return BOTTOM;\n  }\n\n  if (!disabled.left) {\n    if (lowerTopRight && constrain.right) return LEFT;\n    if (lowerTopRight && !constrain.top) return LEFT;\n    if (upperBottomRight && constrain.right) return LEFT;\n    if (upperBottomRight && !constrain.bottom) return LEFT;\n    if (upperTopRight && constrain.right && disabled.bottom) return LEFT;\n    if (lowerBottomRight && constrain.right && disabled.top) return LEFT;\n    if (upperTopRight && !constrain.top && constrain.right) return LEFT;\n    if (lowerBottomRight && !constrain.bottom && constrain.right) return LEFT;\n  }\n\n  return undefined;\n}\n\n/**\n * Get the opposite region of the one provided.\n * i.e. `left` -> `right`, `top` -> `bottom`\n *\n * @param   {string} region A region (`top`, `right`, `bottom`, or `left`).\n * @returns {string} The inverse region.\n */\nfunction invertRegion(region: Region): Region {\n  return {\n    top: BOTTOM,\n    bottom: TOP,\n    left: RIGHT,\n    right: LEFT,\n  }[region];\n}\n\n/**\n * Return the default region set in the config, or its inverse if either are\n * valid.\n *\n * Using the inverse helps preserve visual continuity when the content meets the\n * edge of the bounds rect; instead of appearing to rotate 90 degrees around the\n * target, inverting it will cause it to appear to flip, which is more visually\n * appealing.\n *\n * @param   {Object} config FlowTip layout config object.\n * @param   {Object} valid Valid regions (`{top, right, bottom, left}`).\n * @returns {string|undefined} A region (`top`, `right`, `bottom`, or `left`).\n */\nfunction getDefaultRegion(config: _Config, valid: _Regions): ?Region {\n  const {region} = config;\n\n  if (typeof region === 'string') {\n    if (valid[region] && !config.disabled[region]) {\n      return region;\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Return the default region set in the config, or its inverse if either are\n * valid.\n *\n * Using the inverse helps preserve visual continuity when the content meets the\n * edge of the bounds rect; instead of appearing to rotate 90 degrees around the\n * target, inverting it will cause it to appear to flip, which is more visually\n * appealing.\n *\n * @param   {Object} config FlowTip layout config object.\n * @param   {Object} valid Valid regions (`{top, right, bottom, left}`).\n * @returns {string|undefined} A region (`top`, `right`, `bottom`, or `left`).\n */\nfunction getInvertDefaultRegion(config: _Config, valid: _Regions): ?Region {\n  const {region} = config;\n\n  if (typeof region === 'string') {\n    const invertedDefault = invertRegion(region);\n    if (valid[invertedDefault] && !config.disabled[invertedDefault]) {\n      return invertedDefault;\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * If a correct region could not be resolved due to one or more regions\n * disabled in the config, we need to return a fallback region. This may\n * result in the content rect getting inadvertently clipped with the\n * bounds rect or the target rect, but there is nothing else we can do.\n *\n * @param   {Object} config FlowTip layout config object.\n * @param   {Object} valid Valid regions (`{top, right, bottom, left}`).\n * @returns {string} A region (`top`, `right`, `bottom`, or `left`).\n */\nfunction getFallbackRegion(config: _Config): Region {\n  // Prioritize the configured default region.\n  let fallback: ?Region = config.region;\n\n  // If the default region is not set or is disabled, pick the first enabled\n  // region.\n  if (typeof fallback !== 'string' || config.disabled[fallback]) {\n    fallback = Object.keys(config.disabled).find(\n      (region) => !config.disabled[region],\n    );\n  }\n\n  // ALL OF THE REGIONS ARE DISABLED ಠ_ಠ\n  if (typeof fallback !== 'string') {\n    fallback = TOP;\n  }\n\n  return fallback;\n}\n\n/**\n * Get the current region that should be occupied by the content rect.\n *\n * @param   {Object} config FlowTip layout config object.\n * @param   {Object} valid Valid regions (`{top, right, bottom, left}`).\n * @returns {array} Array containing region and reason.\n */\nfunction getRegion(config: _Config, valid: _Regions): [Region, Reason] {\n  const ideal = getIdealRegion(config, valid);\n\n  // Return the default region set in the config if it is valid.\n  const defaultRegion = getDefaultRegion(config, valid);\n\n  if (typeof defaultRegion === 'string') {\n    return [defaultRegion, defaultRegion === ideal ? 'ideal' : 'default'];\n  }\n\n  // Return the default region set in the config if it is valid.\n  const invertedDefault = getInvertDefaultRegion(config, valid);\n\n  if (typeof invertedDefault === 'string') {\n    return [invertedDefault, invertedDefault === ideal ? 'ideal' : 'inverted'];\n  }\n\n  // Return the region with the most valid space.\n  if (typeof ideal === 'string') {\n    return [ideal, 'ideal'];\n  }\n\n  // Retun the region from the external calculation if one is returned.\n  const external = getExternalRegion(config);\n  if (typeof external === 'string') {\n    return [external, 'external'];\n  }\n\n  const fallback = getFallbackRegion(config);\n\n  return [fallback, 'fallback'];\n}\n\n/**\n * Get the updated left position of the content rect with boundary constraints\n * applied.\n *\n * @param   {Object} config FlowTip layout config object.\n * @param   {string} region A region (`top`, `right`, `bottom`, or `left`).\n * @param   {Object} rect A content rect object.\n * @returns {Object} A repositioned content rect.\n */\nfunction constrainRect(config: _Config, region: Region, rect: Rect): Rect {\n  const offsetBounds = getOffsetBounds(config, region);\n\n  const left = constrainLeft(config, region, offsetBounds, rect);\n  const top = constrainTop(config, region, offsetBounds, rect);\n\n  return new Rect(left, top, rect.width, rect.height);\n}\n\n/**\n * Get the distance between the target rect and the content rect along the\n * normal of the region.\n *\n * If the content rect intersects the target rect, the returned value is\n * negative.\n *\n * @param   {Object} config FlowTip layout config object.\n * @param   {string} region A region (`top`, `right`, `bottom`, or `left`).\n * @param   {Object} rect A content rect object.\n * @returns {number} Distance between target and content.\n */\nfunction getOffset(config: _Config, region: Region, rect: Rect): number {\n  const {target} = config;\n\n  if (region === TOP) {\n    return target.top - rect.bottom;\n  } else if (region === RIGHT) {\n    return rect.left - target.right;\n  } else if (region === BOTTOM) {\n    return rect.top - target.bottom;\n  }\n\n  // Region is left.\n  return target.left - rect.right;\n}\n\n/**\n * Get the current linear overlap between the content rect and the target rect.\n *\n * @param   {string} region A region (`top`, `right`, `bottom`, or `left`).\n * @param   {Object} intersect The intersection rect of the target and content.\n * @returns {number} Overlap between target and content.\n */\nfunction getOverlap(region: Region, intersect: Rect): number {\n  if (region === TOP || region === BOTTOM) {\n    return intersect.width;\n  }\n\n  // Region is left or right.\n  return intersect.height;\n}\n\n/**\n * Get the center position of the liner overlap range between the content rect\n * and the target rect. This value is calculated to use as a style input when\n * rendering an indicator.\n *\n * The value returned is relative to the top or left edge of the content rect.\n * This is for convenience since an indicator will most likely be rendered as\n * a child of the content element.\n *\n *\n *     |‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|\n *     |            content             |\n *     |________________________________|\n *     |                  |      V      |\n *     |<--overlap-center-+----->|      |\n *                        |<-----+----->|-overlap\n *                        |______|______|____\n *                        |      target      |\n *                         ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n * > The overlap center is relative to the left (or top) edge of the content\n * > rect.\n *\n *     |‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|\n *     |         content         |\n *     |_________________________|\n *     |                         |   V\n *     |<--overlap-center--------+-->|\n *                               |<--+-->|-overlap\n *                                       |__________________\n *                                       |      target      |\n *                                        ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n * > If there is no geometric overlap between the content rect and the target\n * > rect, the overlap center will be longer then the content rect edge or\n * > will be negative.\n *\n\n * @param   {string} region A region (`top`, `right`, `bottom`, or `left`).\n * @param   {Object} rect A content rect object.\n * @param   {Object} intersect The intersection rect of the target and content.\n * @returns {number} Distance to overlap center.\n */\nfunction getCenter(region: Region, rect: Rect, intersect: Rect): number {\n  if (region === TOP || region === BOTTOM) {\n    return intersect.left + intersect.width / 2 - rect.left;\n  }\n\n  // Region is left or right;\n  return intersect.top + intersect.height / 2 - rect.top;\n}\n\nconst allRegions = {top: true, right: true, bottom: true, left: true};\nconst noRegions = {top: false, right: false, bottom: false, left: false};\n\nfunction normalizeAlign(align: ?Align): number {\n  if (typeof align === 'number') {\n    return align;\n  }\n\n  if (align === 'start') {\n    return 0;\n  }\n\n  if (align === 'end') {\n    return 1;\n  }\n\n  return 0.5;\n}\n\nfunction defaults(config: Config): _Config {\n  const {\n    offset = 0,\n    overlap = 0,\n    edgeOffset = 0,\n    align,\n    region,\n    bounds,\n    target,\n    content,\n    disabled,\n    constrain,\n  } = config;\n\n  return {\n    offset,\n    overlap,\n    edgeOffset,\n    align: normalizeAlign(align),\n    region,\n    bounds: Rect.from(bounds),\n    target: Rect.from(target),\n    content,\n    disabled: {...noRegions, ...disabled},\n    constrain: {...allRegions, ...constrain},\n  };\n}\n\n/**\n * Calculate a FlowTip layout result.\n *\n * @param   {Object} config FlowTip layout config object.\n * @param   {Object} config.target A rect representing the target element.\n * @param   {Object} config.content A rect representing the content element.\n * @param   {string} [config.region] The default region\n *                                   (`top`, `right`, `bottom`, or `left`).\n * @param   {string} config.disabled Disabled regions\n *                                   (`{top, right, bottom, left}`).\n * @param   {string} config.constrain Constrained regions\n *                                    (`{top, right, bottom, left}`).\n * @param   {number} [config.offset=0] Target-content offset.\n * @param   {number} [config.overlap=0] Min target-content liner overlap.\n * @param   {number} [config.align=0.5] Target-content align factor.\n * @returns {Object} FlowTip layout result object.\n */\nfunction flowtip(config: Config): Result {\n  const finalConfig = defaults(config);\n\n  const valid = getValidRegions(finalConfig);\n\n  const [region, reason] = getRegion(finalConfig, valid);\n\n  const tempRect = getRect(finalConfig, region);\n\n  const rect = constrainRect(finalConfig, region, tempRect);\n\n  const intersect = Rect.intersect(finalConfig.target, rect);\n\n  const offset = getOffset(finalConfig, region, rect);\n\n  const overlap = getOverlap(region, intersect);\n\n  const overlapCenter = getCenter(region, rect, intersect);\n\n  return {\n    bounds: finalConfig.bounds,\n    target: finalConfig.target,\n    region,\n    reason,\n    rect,\n    valid,\n    offset,\n    overlap,\n    overlapCenter,\n  };\n}\n\nexport default flowtip;\n"],"file":"flowtip.js"}