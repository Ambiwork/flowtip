{"version":3,"sources":["../src/FlowTip.js"],"names":["STATIC_RESULT","bounds","Rect","zero","target","region","reason","rect","valid","top","right","bottom","left","offset","overlap","overlapCenter","_static","FlowTip","containingBlock","boundedByViewport","content","contentBorders","tail","result","_nextContent","width","height","_updateState","props","_nextTail","_nextContainingBlock","_getContainingBlockRect","_nextBounds","_getBoundsRect","_isMounted","_updateDOMNodes","window","addEventListener","_handleScroll","nextProps","_containingBlockNode","_clippingBlockNode","_node","removeEventListener","Tail","intermediateState","state","edgeOffset","align","config","disabled","topDisabled","rightDisabled","bottomDisabled","leftDisabled","constrain","constrainTop","constrainRight","constrainBottom","constrainLeft","document","documentElement","areEqual","sticky","targetOffset","tailOffset","setState","_getState","processBounds","boundsRect","visibleBounds","intersect","isValid","body","scrollLeft","scrollTop","scrollWidth","scrollHeight","node","HTMLElement","parentNode","render","onTailSize","_handleTailSize","onContentSize","_handleContentSize","React","Component","undefined","CENTER","defaultRender"],"mappings":"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","sourcesContent":["// @flow\n\nimport * as React from 'react';\nimport flowtip, {CENTER, Rect, areEqualDimensions} from 'flowtip-core';\nimport type {RectLike, Region, Dimensions, Result} from 'flowtip-core';\n\nimport type {Props, State} from './types';\nimport findDOMNode from './util/findDOMNode';\nimport {\n  getBorders,\n  getContainingBlock,\n  getClippingBlock,\n  getContentRect,\n  getViewportRect,\n} from './util/dom';\nimport {getRegion, getOverlap, getOffset} from './util/state';\nimport defaultRender from './defaultRender';\n\n// Static `flowtip` layout calculation result mock for use during initial client\n// side render or on server render where DOM feedback is not possible.\nconst STATIC_RESULT: Result = {\n  bounds: Rect.zero,\n  target: Rect.zero,\n  region: 'bottom',\n  reason: 'default',\n  rect: Rect.zero,\n  valid: {top: false, right: false, bottom: true, left: false},\n  offset: 0,\n  overlap: 0,\n  overlapCenter: 0,\n  _static: true,\n};\n\nclass FlowTip extends React.Component<Props, State> {\n  static defaultProps = {\n    bounds: null,\n    region: undefined,\n    sticky: true,\n    targetOffset: 0,\n    edgeOffset: 0,\n    tailOffset: 0,\n    align: CENTER,\n    topDisabled: false,\n    rightDisabled: false,\n    bottomDisabled: false,\n    leftDisabled: false,\n    constrainTop: true,\n    constrainRight: true,\n    constrainBottom: true,\n    constrainLeft: true,\n    render: defaultRender,\n  };\n\n  _nextContent: Dimensions | null = null;\n  _nextTail: Dimensions | null = null;\n  _nextContainingBlock: Rect = Rect.zero;\n  _nextBounds: Rect | null = null;\n  _lastRegion: Region | void;\n  _isMounted: boolean = false;\n  _containingBlockNode: HTMLElement | null = null;\n  _clippingBlockNode: HTMLElement | null = null;\n  _node: HTMLElement | null = null;\n  state = {\n    containingBlock: Rect.zero,\n    boundedByViewport: true,\n    bounds: null,\n    content: null,\n    contentBorders: null,\n    tail: null,\n    result: STATIC_RESULT,\n  };\n\n  // Lifecycle Methods =========================================================\n\n  componentDidMount(): void {\n    this._isMounted = true;\n\n    this._updateDOMNodes();\n    this._nextContainingBlock = this._getContainingBlockRect();\n    this._nextBounds = this._getBoundsRect(this.props);\n\n    this._updateState(this.props);\n\n    window.addEventListener('scroll', this._handleScroll);\n    window.addEventListener('resize', this._handleScroll);\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps: Props): void {\n    this._nextContainingBlock = this._getContainingBlockRect();\n    this._nextBounds = this._getBoundsRect(nextProps);\n\n    this._updateState(nextProps);\n  }\n\n  componentDidUpdate(): void {\n    this._updateDOMNodes();\n  }\n\n  componentWillUnmount(): void {\n    this._isMounted = false;\n\n    this._containingBlockNode = null;\n    this._clippingBlockNode = null;\n    this._node = null;\n\n    window.removeEventListener('scroll', this._handleScroll);\n    window.removeEventListener('resize', this._handleScroll);\n  }\n\n  // State Management ==========================================================\n\n  /**\n   * Get the next state.\n   *\n   * This method uses any cached measurements in combination with the provided\n   * props to get a new `flowtip` layout result. The element measurements used\n   * as inputs to `flowtip` are also cached in the state to compare against the\n   * next requested state update.\n   *\n   * Note: `props` are passed in as an argument to allow using this method from\n   * within `componentWillReceiveProps`.\n   *\n   * @param   {Object} nextProps - FlowTip props.\n   * @returns {void}\n   */\n  _getState(nextProps: Props): State {\n    const containingBlock = this._nextContainingBlock;\n    const bounds = this._nextBounds;\n    const content = this._nextContent;\n    const tail = this._nextTail;\n    const target = nextProps.target;\n\n    let result = STATIC_RESULT;\n\n    if (\n      bounds &&\n      target &&\n      content &&\n      (typeof nextProps.Tail !== 'function' || tail)\n    ) {\n      const intermediateState = {\n        ...this.state,\n        bounds,\n        containingBlock,\n        tail,\n        content,\n      };\n\n      const offset = getOffset(nextProps, intermediateState);\n      const overlap = getOverlap(nextProps, intermediateState);\n      const region = getRegion(nextProps, intermediateState);\n      const {edgeOffset = offset, align} = nextProps;\n\n      const config = {\n        offset,\n        edgeOffset,\n        overlap,\n        align,\n        region,\n        bounds,\n        target,\n        content,\n        disabled: {\n          top: nextProps.topDisabled,\n          right: nextProps.rightDisabled,\n          bottom: nextProps.bottomDisabled,\n          left: nextProps.leftDisabled,\n        },\n        constrain: {\n          top: nextProps.constrainTop,\n          right: nextProps.constrainRight,\n          bottom: nextProps.constrainBottom,\n          left: nextProps.constrainLeft,\n        },\n      };\n\n      result = flowtip(config);\n    }\n\n    const contentBorders = this._node ? getBorders(this._node) : null;\n\n    const boundedByViewport =\n      !nextProps.bounds && this._clippingBlockNode === document.documentElement;\n\n    return {\n      containingBlock,\n      boundedByViewport,\n      bounds,\n      content,\n      contentBorders,\n      tail,\n      result,\n    };\n  }\n\n  /**\n   * Trigger a state update and render if necessary.\n   *\n   * Note: `props` are passed in as an argument to allow using this method from\n   * within `componentWillReceiveProps`.\n   *\n   * @param   {Object} nextProps - FlowTip props.\n   * @returns {void}\n   */\n  _updateState(nextProps: Props): void {\n    if (!this._isMounted) return;\n\n    // Only trigger a state update if the dynamic measurements have changed\n    // since the last update. We can optimize here since the `flowtip` layout\n    // calculation is an entire pure function - we would get the same result.\n    if (\n      !areEqualDimensions(this.state.content, this._nextContent) ||\n      !areEqualDimensions(this.state.tail, this._nextTail) ||\n      !Rect.areEqual(this.state.containingBlock, this._nextContainingBlock) ||\n      !Rect.areEqual(this.state.bounds, this._nextBounds) ||\n      !Rect.areEqual(this.props.target, nextProps.target) ||\n      this.props.region !== nextProps.region ||\n      this.props.sticky !== nextProps.sticky ||\n      this.props.targetOffset !== nextProps.targetOffset ||\n      this.props.edgeOffset !== nextProps.edgeOffset ||\n      this.props.tailOffset !== nextProps.tailOffset ||\n      this.props.align !== nextProps.align ||\n      this.props.topDisabled !== nextProps.topDisabled ||\n      this.props.rightDisabled !== nextProps.rightDisabled ||\n      this.props.bottomDisabled !== nextProps.bottomDisabled ||\n      this.props.leftDisabled !== nextProps.leftDisabled ||\n      this.props.constrainTop !== nextProps.constrainTop ||\n      this.props.constrainRight !== nextProps.constrainRight ||\n      this.props.constrainBottom !== nextProps.constrainBottom ||\n      this.props.constrainLeft !== nextProps.constrainLeft\n    ) {\n      this.setState(this._getState(nextProps));\n    }\n  }\n\n  // DOM Measurement Methods ===================================================\n\n  _getBoundsRect(nextProps: Props): Rect | null {\n    const processBounds = (boundsRect: RectLike) => {\n      const visibleBounds = Rect.intersect(getViewportRect(), boundsRect);\n\n      return Rect.isValid(visibleBounds) ? visibleBounds : null;\n    };\n\n    if (nextProps.bounds) {\n      return processBounds(nextProps.bounds);\n    }\n\n    if (document.body && this._clippingBlockNode === document.documentElement) {\n      return processBounds(\n        new Rect(\n          -document.body.scrollLeft,\n          -document.body.scrollTop,\n          document.body.scrollWidth,\n          document.body.scrollHeight,\n        ),\n      );\n    }\n\n    if (this._clippingBlockNode) {\n      return processBounds(getContentRect(this._clippingBlockNode));\n    }\n\n    return null;\n  }\n\n  _getContainingBlockRect(): Rect {\n    if (!this._containingBlockNode) {\n      return Rect.zero;\n    }\n\n    if (\n      document.body &&\n      this._containingBlockNode === document.documentElement\n    ) {\n      return new Rect(\n        -document.body.scrollLeft,\n        -document.body.scrollTop,\n        document.body.scrollWidth,\n        document.body.scrollHeight,\n      );\n    }\n\n    return getContentRect(this._containingBlockNode);\n  }\n\n  // DOM Element Accessors =====================================================\n\n  _updateDOMNodes(): void {\n    const node = findDOMNode(this);\n\n    if (node instanceof HTMLElement) {\n      this._node = node;\n\n      this._containingBlockNode = getContainingBlock(node.parentNode);\n\n      this._clippingBlockNode = getClippingBlock(node.parentNode);\n    }\n  }\n\n  // Event Handlers ============================================================\n\n  /**\n   * Content `ResizeObserver` handler.\n   *\n   * Responds to changes in the dimensions of the rendered content and updates\n   * the cached `_nextContent` rect and triggers a state update.\n   *\n   * @param   {Object} rect - Object with `width` and `height` properties.\n   * @returns {void}\n   */\n  _handleContentSize = (rect: Dimensions) => {\n    this._nextContent = {width: rect.width, height: rect.height};\n    this._updateState(this.props);\n  };\n\n  /**\n   *\n   * Tail `ResizeObserver` handler.\n   *\n   * Responds to changes in the dimensions of the rendered tail element and\n   * updates the cached `_nextContent` rect and triggers a state update.\n   *\n   * @param   {Object} rect - Object with `width` and `height` properties.\n   * @returns {void}\n   */\n  _handleTailSize = (rect: Dimensions) => {\n    this._nextTail = {width: rect.width, height: rect.height};\n    this._updateState(this.props);\n  };\n\n  /**\n   * Window scroll handler.\n   *\n   * Responds to changes in the window scroll position to update the cached\n   * `_nextContainingBlock` and `_nextBounds` rects and triggers a state update.\n   *\n   * @returns {void}\n   */\n  _handleScroll = () => {\n    this._nextContainingBlock = this._getContainingBlockRect();\n    this._nextBounds = this._getBoundsRect(this.props);\n    this._updateState(this.props);\n  };\n\n  render(): React.Node {\n    return this.props.render({\n      onTailSize: this._handleTailSize,\n      onContentSize: this._handleContentSize,\n      state: this.state,\n      props: this.props,\n    });\n  }\n}\n\nexport default FlowTip;\n"],"file":"FlowTip.js"}