{"version":3,"sources":["../../src/util/render.js"],"names":["getContentStyle","props","state","result","_static","position","clip","Rect","areEqual","bounds","isValid","intersect","target","constrainTop","region","top","Math","round","rect","left","constrainRight","right","window","innerWidth","constrainBottom","bottom","innerHeight","constrainLeft","containingBlock","getTailStyle","tailAttached","offset","style","visibility","tail","contentBorders","borders","tailOffset","RIGHT","LEFT"],"mappings":";;;;;;;AAEA;;AAGA;;AACA;;AAEA;;;;;;;;AAQO,IAAMA,kBAAkB,SAAlBA,eAAkB,CAACC,KAAD,EAAeC,KAAf,EAAgC;AAC7D;AACA;AACA,MAAIA,MAAMC,MAAN,CAAaC,OAAb,KAAyB,IAA7B,EAAmC;AACjC,WAAO;AACLC,gBAAU,UADL;AAELC,YAAM;AAFD,KAAP;AAID;;AAED,MACEC,kBAAKC,QAAL,CAAcN,MAAMC,MAAN,CAAaM,MAA3B,EAAmC,2BAAnC,KACA,CAACF,kBAAKG,OAAL,CAAaH,kBAAKI,SAAL,CAAeT,MAAMC,MAAN,CAAaM,MAA5B,EAAoCP,MAAMC,MAAN,CAAaS,MAAjD,CAAb,CAFH,EAGE;AACA,QAAIX,MAAMY,YAAN,IAAsBX,MAAMC,MAAN,CAAaW,MAAb,KAAwB,QAAlD,EAA4D;AAC1D,aAAO;AACLT,kBAAU,OADL;AAELU,aAAKC,KAAKC,KAAL,CAAWf,MAAMC,MAAN,CAAae,IAAb,CAAkBH,GAA7B,CAFA;AAGLI,cAAMH,KAAKC,KAAL,CAAWf,MAAMC,MAAN,CAAae,IAAb,CAAkBC,IAA7B;AAHD,OAAP;AAKD;;AAED,QAAIlB,MAAMmB,cAAN,IAAwBlB,MAAMC,MAAN,CAAaW,MAAb,KAAwB,MAApD,EAA4D;AAC1D,aAAO;AACLT,kBAAU,OADL;AAELU,aAAKC,KAAKC,KAAL,CAAWf,MAAMC,MAAN,CAAae,IAAb,CAAkBH,GAA7B,CAFA;AAGLM,eAAOL,KAAKC,KAAL,CAAWK,OAAOC,UAAP,GAAoBrB,MAAMC,MAAN,CAAae,IAAb,CAAkBG,KAAjD;AAHF,OAAP;AAKD;;AAED,QAAIpB,MAAMuB,eAAN,IAAyBtB,MAAMC,MAAN,CAAaW,MAAb,KAAwB,KAArD,EAA4D;AAC1D,aAAO;AACLT,kBAAU,OADL;AAELoB,gBAAQT,KAAKC,KAAL,CAAWK,OAAOI,WAAP,GAAqBxB,MAAMC,MAAN,CAAae,IAAb,CAAkBO,MAAlD,CAFH;AAGLN,cAAMH,KAAKC,KAAL,CAAWf,MAAMC,MAAN,CAAae,IAAb,CAAkBC,IAA7B;AAHD,OAAP;AAKD;;AAED,QAAIlB,MAAM0B,aAAN,IAAuBzB,MAAMC,MAAN,CAAaW,MAAb,KAAwB,OAAnD,EAA4D;AAC1D,aAAO;AACLT,kBAAU,OADL;AAELU,aAAKC,KAAKC,KAAL,CAAWf,MAAMC,MAAN,CAAae,IAAb,CAAkBH,GAA7B,CAFA;AAGLI,cAAMH,KAAKC,KAAL,CAAWf,MAAMC,MAAN,CAAae,IAAb,CAAkBC,IAA7B;AAHD,OAAP;AAKD;AACF;;AAED,SAAO;AACLd,cAAU,UADL;AAELU,SAAKC,KAAKC,KAAL,CAAWf,MAAMC,MAAN,CAAae,IAAb,CAAkBH,GAAlB,GAAwBb,MAAM0B,eAAN,CAAsBb,GAAzD,CAFA;AAGLI,UAAMH,KAAKC,KAAL,CAAWf,MAAMC,MAAN,CAAae,IAAb,CAAkBC,IAAlB,GAAyBjB,MAAM0B,eAAN,CAAsBT,IAA1D;AAHD,GAAP;AAKD,CApDM;AAsDP;;;;;;;;;;;;AAQO,IAAMU,eAAe,SAAfA,YAAe,CAAC5B,KAAD,EAAeC,KAAf,EAAgC;AAC1D,MAAI,CAACA,MAAMC,MAAX,EAAmB,OAAO;AAACE,cAAU;AAAX,GAAP;AAEnB,MAAMyB,eAAe5B,MAAMC,MAAN,CAAa4B,MAAb,IAAuB,sBAAU9B,KAAV,EAAiBC,KAAjB,CAA5C;AAEA,MAAM8B,QAAe;AACnB3B,cAAU,UADS;AAEnB4B,gBAAYH,eAAe,SAAf,GAA2B;AAFpB,GAArB;;AAKA,MAAI5B,MAAMgC,IAAN,IAAchC,MAAMiC,cAAxB,EAAwC;AACtC,QAAMC,UAAUlC,MAAMiC,cAAtB;AAEA,QAAM9B,WAAW,yCACfH,MAAMC,MADS,EAEfD,MAAMgC,IAFS,EAGfjC,MAAMoC,UAHS,CAAjB,CAHsC,CAStC;AACA;AACA;;AACAL,UAAM9B,MAAMC,MAAN,CAAaW,MAAnB,0BACEsB,QAAQlC,MAAMC,MAAN,CAAaW,MAArB,CADF;;AAIA,QAAIZ,MAAMC,MAAN,CAAaW,MAAb,KAAwBwB,kBAAxB,IAAiCpC,MAAMC,MAAN,CAAaW,MAAb,KAAwByB,iBAA7D,EAAmE;AACjEP,YAAMjB,GAAN,GAAYV,WAAW+B,QAAQrB,GAA/B;AACD,KAFD,MAEO;AACLiB,YAAMb,IAAN,GAAad,WAAW+B,QAAQjB,IAAhC;AACD;AACF;;AAED,SAAOa,KAAP;AACD,CAlCM","sourcesContent":["// @flow\n\nimport {Rect, getClampedTailPosition, RIGHT, LEFT} from 'flowtip-core';\n\nimport type {Style, Props, State} from '../types';\nimport {getOffset} from '../util/state';\nimport {getViewportRect} from '../util/dom';\n\n/**\n * Get the content element position style based on the current layout result\n * in the state.\n *\n * @param   {Object} props - FlowTip props.\n * @param   {Object} state - FlowTip props.\n * @returns {Object} Content position style.\n */\nexport const getContentStyle = (props: Props, state: State) => {\n  // Hide the result with css clip - preserving its ability to be measured -\n  // when working with a static layout result mock.\n  if (state.result._static === true) {\n    return {\n      position: 'absolute',\n      clip: 'rect(0 0 0 0)',\n    };\n  }\n\n  if (\n    Rect.areEqual(state.result.bounds, getViewportRect()) &&\n    !Rect.isValid(Rect.intersect(state.result.bounds, state.result.target))\n  ) {\n    if (props.constrainTop && state.result.region === 'bottom') {\n      return {\n        position: 'fixed',\n        top: Math.round(state.result.rect.top),\n        left: Math.round(state.result.rect.left),\n      };\n    }\n\n    if (props.constrainRight && state.result.region === 'left') {\n      return {\n        position: 'fixed',\n        top: Math.round(state.result.rect.top),\n        right: Math.round(window.innerWidth - state.result.rect.right),\n      };\n    }\n\n    if (props.constrainBottom && state.result.region === 'top') {\n      return {\n        position: 'fixed',\n        bottom: Math.round(window.innerHeight - state.result.rect.bottom),\n        left: Math.round(state.result.rect.left),\n      };\n    }\n\n    if (props.constrainLeft && state.result.region === 'right') {\n      return {\n        position: 'fixed',\n        top: Math.round(state.result.rect.top),\n        left: Math.round(state.result.rect.left),\n      };\n    }\n  }\n\n  return {\n    position: 'absolute',\n    top: Math.round(state.result.rect.top - state.containingBlock.top),\n    left: Math.round(state.result.rect.left - state.containingBlock.left),\n  };\n};\n\n/**\n * Get the tail element position style based on the current layout result in\n * the state.\n *\n * @param   {Object} props - FlowTip props.\n * @param   {Object} state - FlowTip props.\n * @returns {Object} Tail position style.\n */\nexport const getTailStyle = (props: Props, state: State) => {\n  if (!state.result) return {position: 'absolute'};\n\n  const tailAttached = state.result.offset >= getOffset(props, state);\n\n  const style: Style = {\n    position: 'absolute',\n    visibility: tailAttached ? 'visible' : 'hidden',\n  };\n\n  if (state.tail && state.contentBorders) {\n    const borders = state.contentBorders;\n\n    const position = getClampedTailPosition(\n      state.result,\n      state.tail,\n      props.tailOffset,\n    );\n\n    // Position the tail at the opposite edge of the region. i.e. if region is\n    // `right` the style will be `right: 100%`, which will place the tail\n    // at left edge.\n    style[state.result.region] = `calc(100% + ${\n      borders[state.result.region]\n    }px)`;\n\n    if (state.result.region === RIGHT || state.result.region === LEFT) {\n      style.top = position - borders.top;\n    } else {\n      style.left = position - borders.left;\n    }\n  }\n\n  return style;\n};\n"],"file":"render.js"}