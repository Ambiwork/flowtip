{"version":3,"sources":["../../src/util/state.js"],"names":["getLastRegion","props","state","result","_static","region","getRegion","sticky","getTailLength","lastRegion","tail","LEFT","RIGHT","width","height","getTailBase","getOverlap","tailOffset","getOffset","targetOffset"],"mappings":";;;;;;;;;;;;AAEA;;AAIA;;;;;;;AAOO,SAASA,aAAT,CAAuBC,KAAvB,EAAqCC,KAArC,EAAkE;AACvE,SAAOA,MAAMC,MAAN,CAAaC,OAAb,KAAyB,IAAzB,GAAgCH,MAAMI,MAAtC,GAA+CH,MAAMC,MAAN,CAAaE,MAAnE;AACD;AAED;;;;;;;;;;AAQO,SAASC,SAAT,CAAmBL,KAAnB,EAAiCC,KAAjC,EAA8D;AACnE;AACA;AACA;AACA,SAAOD,MAAMM,MAAN,GAAeP,cAAcC,KAAd,EAAqBC,KAArB,CAAf,GAA6CD,MAAMI,MAA1D;AACD;AAED;;;;;;;;;;;;;AAWO,SAASG,aAAT,CAAuBP,KAAvB,EAAqCC,KAArC,EAA2D;AAChE,MAAMO,aAAaT,cAAcC,KAAd,EAAqBC,KAArB,CAAnB;;AAEA,MAAIA,MAAMQ,IAAV,EAAgB;AACd;AACA;AACA,QAAID,eAAeE,iBAAf,IAAuBF,eAAeG,kBAA1C,EAAiD;AAC/C,aAAOV,MAAMQ,IAAN,CAAWG,KAAlB;AACD,KALa,CAMd;AACA;AACA;;;AACA,WAAOX,MAAMQ,IAAN,CAAWI,MAAlB;AACD;;AAED,SAAO,CAAP;AACD;AAED;;;;;;;;;;;;;AAWO,SAASC,WAAT,CAAqBd,KAArB,EAAmCC,KAAnC,EAAyD;AAC9D,MAAMO,aAAaT,cAAcC,KAAd,EAAqBC,KAArB,CAAnB;;AAEA,MAAIA,MAAMQ,IAAV,EAAgB;AACd;AACA;AACA,QAAID,eAAeE,iBAAf,IAAuBF,eAAeG,kBAA1C,EAAiD;AAC/C,aAAOV,MAAMQ,IAAN,CAAWI,MAAlB;AACD,KALa,CAMd;AACA;AACA;;;AACA,WAAOZ,MAAMQ,IAAN,CAAWG,KAAlB;AACD;;AAED,SAAO,CAAP;AACD;AAED;;;;;;;;;;;;;;;;;AAeO,SAASG,UAAT,CAAoBf,KAApB,EAAkCC,KAAlC,EAAwD;AAC7D,SAAOD,MAAMgB,UAAN,GAAmBF,YAAYd,KAAZ,EAAmBC,KAAnB,IAA4B,CAAtD;AACD;AAED;;;;;;;;;;;;;;;AAaO,SAASgB,SAAT,CAAmBjB,KAAnB,EAAiCC,KAAjC,EAAuD;AAC5D;AACA;AACA,SAAOD,MAAMkB,YAAN,GAAqBX,cAAcP,KAAd,EAAqBC,KAArB,CAA5B;AACD","sourcesContent":["// @flow\n\nimport {RIGHT, LEFT} from 'flowtip-core';\nimport type {Region} from 'flowtip-core';\nimport type {Props, State} from '../types';\n\n/**\n * Get the last rendered region (`top`, `right`, `bottom`, or `left`).\n *\n * @param   {Object} props - FlowTip props.\n * @param   {Object} state - FlowTip state.\n * @returns {string} Region.\n */\nexport function getLastRegion(props: Props, state: State): Region | void {\n  return state.result._static === true ? props.region : state.result.region;\n}\n\n/**\n * Get the current region (`top`, `right`, `bottom`, or `left`) that the FlowTip\n * layout algorithm should prioritize in it's result.\n *\n * @param   {Object} props - FlowTip props.\n * @param   {Object} state - FlowTip state.\n * @returns {string} Region.\n */\nexport function getRegion(props: Props, state: State): Region | void {\n  // Feed the current region in as the default if `sticky` is true.\n  // This makes the component stay in its region until it meets a\n  // boundary edge and must change.\n  return props.sticky ? getLastRegion(props, state) : props.region;\n}\n\n/**\n * Get the dimension of the tail perpendicular to the attached edge of the\n * content rect.\n *\n * Note: `props` are passed in as an argument to allow using this method from\n * within `componentWillReceiveProps`.\n *\n * @param   {Object} props - FlowTip props.\n * @param   {Object} state - FlowTip state.\n * @returns {number} Tail length.\n */\nexport function getTailLength(props: Props, state: State): number {\n  const lastRegion = getLastRegion(props, state);\n\n  if (state.tail) {\n    // Swap the width and height into \"base\" and \"length\" to create\n    // measurements that are agnostic to tail orientation.\n    if (lastRegion === LEFT || lastRegion === RIGHT) {\n      return state.tail.width;\n    }\n    // Either lastRegion is top or bottom - or it is undefined, which means\n    // the tail was rendered using the static dummy result that uses the\n    // bottom region.\n    return state.tail.height;\n  }\n\n  return 0;\n}\n\n/**\n * Get the dimension of the tail parallel to the attached edge of the content\n * rect.\n *\n * Note: `props` are passed in as an argument to allow using this method from\n * within `componentWillReceiveProps`.\n *\n * @param   {Object} props - FlowTip props.\n * @param   {Object} state - FlowTip state.\n * @returns {number} Tail base size.\n */\nexport function getTailBase(props: Props, state: State): number {\n  const lastRegion = getLastRegion(props, state);\n\n  if (state.tail) {\n    // Swap the width and height into \"base\" and \"length\" to create\n    // measurements that are agnostic to tail orientation.\n    if (lastRegion === LEFT || lastRegion === RIGHT) {\n      return state.tail.height;\n    }\n    // Either lastRegion is top or bottom - or it is undefined, which means\n    // the tail was rendered using the static dummy result that uses the\n    // bottom region\n    return state.tail.width;\n  }\n\n  return 0;\n}\n\n/**\n * Get current minimum linear overlap value.\n *\n * Overlap ensures that there is always enough room to render a tail that\n * points to the target rect. This will force the content to enter a\n * different region if there is not enough room. The `tailOffset` value\n * is the minimum distance between the tail and the content corner.\n *\n * Note: `props` are passed in as an argument to allow using this method from\n * within `componentWillReceiveProps`.\n *\n * @param   {Object} props - FlowTip props.\n * @param   {Object} state - FlowTip props.\n * @returns {number} Minimum linear overlap.\n */\nexport function getOverlap(props: Props, state: State): number {\n  return props.tailOffset + getTailBase(props, state) / 2;\n}\n\n/**\n * Get the offset between the target and the content rect.\n *\n * The flowtip layout calculation does not factor the dimensions of the tail.\n * This method encodes the tail dimension into the `offset` parameter.\n *\n * Note: `props` are passed in as an argument to allow using this method from\n * within `componentWillReceiveProps`.\n *\n * @param   {Object} props - FlowTip props.\n * @param   {Object} state - FlowTip state.\n * @returns {number} Tail length.\n */\nexport function getOffset(props: Props, state: State): number {\n  // Ensure that the there is `targetOffset` amount of space between the\n  // tail and the target rect.\n  return props.targetOffset + getTailLength(props, state);\n}\n"],"file":"state.js"}