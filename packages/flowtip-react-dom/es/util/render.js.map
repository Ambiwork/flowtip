{"version":3,"sources":["../../src/util/render.js"],"names":["Rect","getClampedTailPosition","RIGHT","LEFT","getOffset","getViewportRect","getContentStyle","props","state","result","_static","position","clip","areEqual","bounds","isValid","intersect","target","constrainTop","region","top","Math","round","rect","left","constrainRight","right","window","innerWidth","constrainBottom","bottom","innerHeight","constrainLeft","containingBlock","getTailStyle","tailAttached","offset","style","visibility","tail","contentBorders","borders","tailOffset"],"mappings":"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","sourcesContent":["// @flow\n\nimport {Rect, getClampedTailPosition, RIGHT, LEFT} from 'flowtip-core';\n\nimport type {Style, Props, State} from '../types';\nimport {getOffset} from '../util/state';\nimport {getViewportRect} from '../util/dom';\n\n/**\n * Get the content element position style based on the current layout result\n * in the state.\n *\n * @param   {Object} props - FlowTip props.\n * @param   {Object} state - FlowTip props.\n * @returns {Object} Content position style.\n */\nexport const getContentStyle = (props: Props, state: State) => {\n  // Hide the result with css clip - preserving its ability to be measured -\n  // when working with a static layout result mock.\n  if (state.result._static === true) {\n    return {\n      position: 'absolute',\n      clip: 'rect(0 0 0 0)',\n    };\n  }\n\n  if (\n    Rect.areEqual(state.result.bounds, getViewportRect()) &&\n    !Rect.isValid(Rect.intersect(state.result.bounds, state.result.target))\n  ) {\n    if (props.constrainTop && state.result.region === 'bottom') {\n      return {\n        position: 'fixed',\n        top: Math.round(state.result.rect.top),\n        left: Math.round(state.result.rect.left),\n      };\n    }\n\n    if (props.constrainRight && state.result.region === 'left') {\n      return {\n        position: 'fixed',\n        top: Math.round(state.result.rect.top),\n        right: Math.round(window.innerWidth - state.result.rect.right),\n      };\n    }\n\n    if (props.constrainBottom && state.result.region === 'top') {\n      return {\n        position: 'fixed',\n        bottom: Math.round(window.innerHeight - state.result.rect.bottom),\n        left: Math.round(state.result.rect.left),\n      };\n    }\n\n    if (props.constrainLeft && state.result.region === 'right') {\n      return {\n        position: 'fixed',\n        top: Math.round(state.result.rect.top),\n        left: Math.round(state.result.rect.left),\n      };\n    }\n  }\n\n  return {\n    position: 'absolute',\n    top: Math.round(state.result.rect.top - state.containingBlock.top),\n    left: Math.round(state.result.rect.left - state.containingBlock.left),\n  };\n};\n\n/**\n * Get the tail element position style based on the current layout result in\n * the state.\n *\n * @param   {Object} props - FlowTip props.\n * @param   {Object} state - FlowTip props.\n * @returns {Object} Tail position style.\n */\nexport const getTailStyle = (props: Props, state: State) => {\n  if (!state.result) return {position: 'absolute'};\n\n  const tailAttached = state.result.offset >= getOffset(props, state);\n\n  const style: Style = {\n    position: 'absolute',\n    visibility: tailAttached ? 'visible' : 'hidden',\n  };\n\n  if (state.tail && state.contentBorders) {\n    const borders = state.contentBorders;\n\n    const position = getClampedTailPosition(\n      state.result,\n      state.tail,\n      props.tailOffset,\n    );\n\n    // Position the tail at the opposite edge of the region. i.e. if region is\n    // `right` the style will be `right: 100%`, which will place the tail\n    // at left edge.\n    style[state.result.region] = `calc(100% + ${\n      borders[state.result.region]\n    }px)`;\n\n    if (state.result.region === RIGHT || state.result.region === LEFT) {\n      style.top = position - borders.top;\n    } else {\n      style.left = position - borders.left;\n    }\n  }\n\n  return style;\n};\n"],"file":"render.js"}